## 소개
기존 방식이 너무 느려서 나온 방법이 하드웨어를 사용해보자! 임
-> MMU의 TLB(Translation Lookaside Buffer)를 사용해서 캐싱을 추가해보자
즉, 하드웨어가 주소변환 계산하기 전에 TLB 먼저 찾아보게 됨

## TLB 기본 동작 과정
1. 가상 주소에서, VPN을 추출해서 해당 VPN에 해당하는 값이 TLB에 들어있는지 확인
2. TLB Hit라면, PFN을 바로 매핑시켜서 원하는 물리 주소를 구성하고 메모리 접근
3. TLB Miss라면, 변환 정보를 찾아야 하니까 **페이지 테이블 주소**로 접근해서 계산 -> 시간 엄청 걸림

즉, Hit하면 엄청 좋은데, Miss 발생하면 좀 안좋은 방법이긴 하다

## 예시

![image](https://github.com/user-attachments/assets/366924a4-60b4-458b-8b87-5d45cbbbf67e)
예를 들어서, 초기화된 TLB가 있다고 가정
a[0] 접근하려고 하면 -> TLB Miss -> 페이지 테이블 방문 -> 실제 주소 계산 후에 TLB 갱신 (해당 VPN, PFN이 TLB에 저장됨)
a[1], a[2] -> TLB Hit -> 바로 PFN으로 실제 주소 계산해서 접근

a[3] -> TLB Miss, a[4],a[5],a[6],a[7] -> TLB Hit

이런 방식으로 동작한다.

## 공간지역성 / 시간지역성
공간 지역성 - 배열을 처음 접근했을때는 Miss였는데, 그 근방에 똑같이 접근하면 Hit 이득을 볼 수 있다
시간 지역성 - 한번 참조한 애는 짧은 시간 내에 또 다시 참조할 수 있다.

## TLB Miss 처리 방법
> TLB Miss는 하드웨어가 처리한다. OS를 믿을수없으니깐...

TLB Miss -> HW Exception 시그널 생성 -> 프로세스 명령어 실행 중지 (현재 PC값 저장) -> 커널 모드로 들어가서 **트랩 핸들러 실행**
-> TLB Miss 처리해서 TLB 갱신 -> 다시 PC값을 사용해서 프로세스 다시 진행

## TLB 사용 시 문맥 교환 문제
> TLB에 있는 VPN, PFN 정보는 해당 프로세스에서만 유효함. 다른 프로세스에는 의미 X

![image](https://github.com/user-attachments/assets/9b1921a3-0f6c-4a15-a402-525f561d6e55)

그럼 위에 그림처럼 서로 다른 프로세스가 동일한 VPN, PFN 정보를 매핑한다면 충돌이 일어나지 않을까??

-> 그래서 추가적인 정보를 넣어줌

### 방법 1. Valid bit를 0으로 설정
- 즉, 문맥 교환 시 TLB를 싹 초기화해버려서 충돌이 발생하지 않도록 함
- 근데, 다시 되돌아온 프로세스는 처음에 무조건 TLB Miss가 나서 그리 좋은 방법은 아님

### 방법 2. 추가 정보를 넣어준다.
![image](https://github.com/user-attachments/assets/a5f42f47-e2ce-4823-916e-be6e45528397)

- PID처럼, TLB 테이블에 아래 그림처럼 ASID 필드를 넣어줘서 어떤 프로세스에 대해 이걸 기록한건지 적어놓는다.
- 따라서 문맥 교환이 일어나도 걱정 X

## TLB 용량 문제

TLB도 하드웨어이고, 엄청 작기 때문에 기존 정보를 계속 교체를 좀 해줘야 한다.
교체 정책은 **LRU(최저 사용 빈도)**기준으로 수행할수도 있고, **Random**으로 교체할수도 있다.
