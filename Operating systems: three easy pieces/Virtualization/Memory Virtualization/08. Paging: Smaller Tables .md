> 이 부분은 시험에 매우매우자주 출제되는 내용이라, 따로 예시 문제 파일로 공부하였다.
> 강의노트 #6, 중간고사 기출문제 참고해서 공부!!!!

# 🌐 PAGING: 작은 페이지 테이블 만들기

페이징 시스템에서는 메모리를 효율적으로 사용하기 위해 페이지 테이블을 작게 만드는 방법이 중요합니다. 
기존의 선형 페이지 테이블 방식은 메모리 공간을 낭비할 수 있기 때문에, 이를 개선하는 여러 기법이 필요합니다.

## 1. 문제점: 선형 페이지 테이블의 메모리 낭비 🚫

선형 페이지 테이블을 사용하면 프로세스의 주소 공간이 커질수록 페이지 테이블도 커지게 됩니다. 
이때, 실제로 사용되지 않는 페이지들이 많이 존재할 수 있고, 이로 인해 메모리 공간이 낭비됩니다. 

예를 들어, 32비트 주소 공간을 가진 시스템에서 최대 **$2^{20}$개의 페이지 항목**이 필요하며, 
각 항목의 크기가 4바이트라면 페이지 테이블의 총 크기는 **4MB**가 됩니다. 

이 페이지 테이블은 모든 가상 페이지를 관리해야 하기 때문에 사용되지 않는 페이지들도 포함되어 메모리를 낭비하게 됩니다.

## 2. 다단계 페이지 테이블 (Multi-level Page Table) 🌳

**다단계 페이지 테이블**은 이러한 문제를 해결하기 위해 도입된 방법입니다. 
페이지 테이블을 여러 단계로 나누어 관리하면서 실제로 사용되는 부분만 메모리에 올려 메모리 효율을 높입니다. 

기본 아이디어는 **페이지 테이블을 여러 작은 페이지 단위로 나누고**, 
**유효하지 않은 페이지는 메모리에 할당하지 않는 것**입니다.

- **페이지 디렉터리 (Page Directory)**: 다단계 페이지 테이블에서는 **페이지 디렉터리**라는 구조를 사용해 각 페이지 테이블의 위치를 추적합니다.
  페이지 디렉터리는 각 페이지 테이블이 메모리에 있는지 여부와 위치를 관리합니다.
  
- **PDE (Page Directory Entry)**: **PDE**는 페이지 디렉터리의 각 항목으로,
  해당 페이지 테이블이 유효한지와 물리 메모리에서 어디에 있는지를 나타냅니다.

예를 들어, 가상 주소 공간이 32비트이고 페이지 크기가 4KB인 경우, 
페이지 테이블의 크기가 너무 커서 (2^20개의 페이지 개수 * 4KB) 모든 항목을 한 번에 저장하기 어렵습니다. 

다단계 페이지 테이블을 사용하면 **상위 10비트는 페이지 디렉터리를 인덱싱**하고, 
**다음 10비트는 실제 페이지 테이블을 인덱싱**하여 효율적으로 페이지를 찾을 수 있습니다.

### 📝 예시: 다단계 페이지 테이블

가상 주소가 **32비트**이고, 페이지 크기가 **4KB(= 2¹² 바이트)**인 경우를 생각해 봅시다. 이때, 가상 주소는 다음과 같이 나눌 수 있습니다:
- **상위 10비트**: 페이지 디렉터리를 인덱싱하여 가상 주소가 어느 페이지 테이블을 참조하는지 결정합니다.
- **중간 10비트**: 해당 페이지 테이블 내에서 어떤 페이지를 참조하는지 나타냅니다.
- **하위 12비트**: 페이지 내 오프셋으로, 페이지 내에서의 정확한 위치를 나타냅니다.

이렇게 **다단계 페이지 테이블**을 사용하면 전체 페이지 테이블을 메모리에 유지할 필요 없이 **사용 중인 부분만** 메모리에 올릴 수 있어 메모리 낭비를 크게 줄일 수 있습니다.

## 3. 역페이지 테이블 (Inverted Page Table) 🔄

다른 방법으로 **역페이지 테이블(Inverted Page Table)**이 있습니다. 
역페이지 테이블은 각 물리 페이지에 대해 하나의 항목만을 유지합니다. 

즉, 모든 가상 페이지에 대해 페이지 테이블을 유지하는 대신 물리 메모리에 존재하는 페이지만 관리하여 메모리 사용량을 줄이는 방식입니다.

- **역페이지 테이블 구조**: 역페이지 테이블에서는 각 항목이 **물리 메모리의 페이지**와 매핑된 **가상 페이지**의 정보를 포함합니다.
  따라서 가상 주소를 물리 주소로 변환할 때 이 테이블을 검색하여 매핑된 페이지를 찾게 됩니다.
  
- **장점**: 이 방식은 페이지 테이블의 크기를 물리 메모리 크기에 맞추기 때문에, 가상 주소 공간의 크기와 관계없이 일정한 크기의 페이지 테이블을 유지할 수 있습니다.

# 8.2 가상 메모리를 위한 OS 정책

![image](https://github.com/user-attachments/assets/99c7b273-45b3-43f0-9d58-39d8e61df259)

## 반입 정책

> 언제 페이지를 주기억 장치로 들여올건지를 결정하는 정책

### 요구 페이징 방식 - 주로 사용하는 방식
- 페이지가 메인 메모리로 반입되는 시점은 **해당 페이지의 특정 부분이 참조될때로 한정**
- 프로세스가 새로 시작하면 많은 페이지 폴트 발생 -> 지역성의 원리에 의해 점차 안정화됨

### 선 페이징 방식
-**페이지 폴트에 의해 요구되는 페이지의 주변 페이지들까지 반입되는 방식**
- 만약 프로세스의 페이지들이 디스크에 연속적으로 저장되어 있을 때, **일련의 연속된 페이지를 한꺼번에 반입**

## 배치 정책
> 프로세스 블록이 메인 메모리의 어디에 위치할 것인지를 결정하는 것
