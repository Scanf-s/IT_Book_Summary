# 🌐 PAGING: 작은 페이지 테이블 만들기

페이징 시스템에서는 메모리를 효율적으로 사용하기 위해 페이지 테이블을 작게 만드는 방법이 중요합니다. 
기존의 선형 페이지 테이블 방식은 메모리 공간을 낭비할 수 있기 때문에, 이를 개선하는 여러 기법이 필요합니다.

## 1. 문제점: 선형 페이지 테이블의 메모리 낭비 🚫

선형 페이지 테이블을 사용하면 프로세스의 주소 공간이 커질수록 페이지 테이블도 커지게 됩니다. 
이때, 실제로 사용되지 않는 페이지들이 많이 존재할 수 있고, 이로 인해 메모리 공간이 낭비됩니다. 

예를 들어, 32비트 주소 공간을 가진 시스템에서 최대 **$2^{20}$개의 페이지 항목**이 필요하며, 
각 항목의 크기가 4바이트라면 페이지 테이블의 총 크기는 **4MB**가 됩니다. 

이 페이지 테이블은 모든 가상 페이지를 관리해야 하기 때문에 사용되지 않는 페이지들도 포함되어 메모리를 낭비하게 됩니다.

## 2. 다단계 페이지 테이블 (Multi-level Page Table) 🌳

**다단계 페이지 테이블**은 이러한 문제를 해결하기 위해 도입된 방법입니다. 
페이지 테이블을 여러 단계로 나누어 관리하면서 실제로 사용되는 부분만 메모리에 올려 메모리 효율을 높입니다. 

기본 아이디어는 **페이지 테이블을 여러 작은 페이지 단위로 나누고**, 
**유효하지 않은 페이지는 메모리에 할당하지 않는 것**입니다.

- **페이지 디렉터리 (Page Directory)**: 다단계 페이지 테이블에서는 **페이지 디렉터리**라는 구조를 사용해 각 페이지 테이블의 위치를 추적합니다.
  페이지 디렉터리는 각 페이지 테이블이 메모리에 있는지 여부와 위치를 관리합니다.
  
- **PDE (Page Directory Entry)**: **PDE**는 페이지 디렉터리의 각 항목으로,
  해당 페이지 테이블이 유효한지와 물리 메모리에서 어디에 있는지를 나타냅니다.

예를 들어, 가상 주소 공간이 32비트이고 페이지 크기가 4KB인 경우, 
페이지 테이블의 크기가 너무 커서 (2^20개의 페이지 개수 * 4KB) 모든 항목을 한 번에 저장하기 어렵습니다. 

다단계 페이지 테이블을 사용하면 **상위 10비트는 페이지 디렉터리를 인덱싱**하고, 
**다음 10비트는 실제 페이지 테이블을 인덱싱**하여 효율적으로 페이지를 찾을 수 있습니다.

### 📝 예시: 다단계 페이지 테이블

가상 주소가 **32비트**이고, 페이지 크기가 **4KB(= 2¹² 바이트)**인 경우를 생각해 봅시다. 이때, 가상 주소는 다음과 같이 나눌 수 있습니다:
- **상위 10비트**: 페이지 디렉터리를 인덱싱하여 가상 주소가 어느 페이지 테이블을 참조하는지 결정합니다.
- **중간 10비트**: 해당 페이지 테이블 내에서 어떤 페이지를 참조하는지 나타냅니다.
- **하위 12비트**: 페이지 내 오프셋으로, 페이지 내에서의 정확한 위치를 나타냅니다.

이렇게 **다단계 페이지 테이블**을 사용하면 전체 페이지 테이블을 메모리에 유지할 필요 없이 **사용 중인 부분만** 메모리에 올릴 수 있어 메모리 낭비를 크게 줄일 수 있습니다.

## 3. 역페이지 테이블 (Inverted Page Table) 🔄

다른 방법으로 **역페이지 테이블(Inverted Page Table)**이 있습니다. 
역페이지 테이블은 각 물리 페이지에 대해 하나의 항목만을 유지합니다. 

즉, 모든 가상 페이지에 대해 페이지 테이블을 유지하는 대신 물리 메모리에 존재하는 페이지만 관리하여 메모리 사용량을 줄이는 방식입니다.

- **역페이지 테이블 구조**: 역페이지 테이블에서는 각 항목이 **물리 메모리의 페이지**와 매핑된 **가상 페이지**의 정보를 포함합니다.
  따라서 가상 주소를 물리 주소로 변환할 때 이 테이블을 검색하여 매핑된 페이지를 찾게 됩니다.
  
- **장점**: 이 방식은 페이지 테이블의 크기를 물리 메모리 크기에 맞추기 때문에, 가상 주소 공간의 크기와 관계없이 일정한 크기의 페이지 테이블을 유지할 수 있습니다.

### 📝 예시: 역페이지 테이블

예를 들어, **물리 메모리**에 **4개의 페이지 프레임**이 있다고 가정해 봅시다. 각 프레임의 크기가 **64바이트**이며, 
역페이지 테이블을 사용하여 각 프레임에 매핑된 **가상 페이지** 정보를 유지합니다. 

가상 주소를 물리 주소로 변환할 때 역페이지 테이블을 검색해 해당 가상 페이지가 어느 물리 프레임에 있는지를 찾습니다. 
이 방식은 **가상 주소 공간이 커져도 물리 메모리 크기에 맞춰 페이지 테이블 크기를 유지**할 수 있어 매우 효율적입니다.

## 4. 메모리 절약의 효과 💾

**다단계 페이지 테이블**과 **역페이지 테이블**은 모두 **메모리 절약**에 큰 효과가 있습니다. 
특히, 프로세스의 주소 공간이 매우 크거나 많은 프로세스가 동시에 실행될 때 이런 기법들은 메모리 사용량을 줄이는 데 매우 유리합니다. 

- **다단계 페이지 테이블**은 사용되지 않는 페이지 테이블을 메모리에 올리지 않음으로써 메모리 효율을 높입니다.
- **역페이지 테이블**은 물리 메모리에 실제로 존재하는 페이지만 관리함으로써 메모리 공간을 절약할 수 있습니다.

### 📝 예시: 메모리 절약 효과 비교

만약 **단일 레벨 페이지 테이블**을 사용해 32비트 가상 주소 공간을 관리할 경우, 
모든 가상 페이지를 위한 항목을 유지해야 하므로 페이지 테이블의 크기는 **4MB**가 됩니다. 

하지만 **다단계 페이지 테이블**을 사용하면 필요한 부분만 메모리에 올리기 때문에 **1MB 이하**의 메모리만으로 충분할 수 있습니다. 
**역페이지 테이블**의 경우, 물리 메모리가 1GB라면 페이지 테이블의 크기는 **수십 KB** 정도로 매우 작게 유지될 수 있습니다.
