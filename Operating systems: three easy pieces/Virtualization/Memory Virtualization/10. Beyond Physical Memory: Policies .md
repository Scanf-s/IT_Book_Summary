## 10.1 캐시 관리

시스템 전체 페이지들 중 일부분만 메인 메모리에 유지되기 때문에
메인 메모리는 시스템의 가상 메모리 페이지를 가져다 놓기 위한 캐시 역할로도 생각할 수 있다.

이 캐시를 위한 교체 정책의 목표는 **Cache miss 횟수를 최소화 해야 한다는 것**
-> 디스크로부터 페이지를 가져오는 횟수를 최소화하자
-> Cache Hit 비율을 최대로 하자
-> PTE Present bit가 1인 항목이 최대가 되게 하자

주어진 내용은 **평균 메모리 접근 시간(Average Memory Access Time, AMAT)**을 계산하는 방법과 이를 실제 사례에 적용한 예시를 설명하고 있습니다. 이를 간단하게 정리해드리겠습니다.

### **AMAT (Average Memory Access Time) 공식**
- **AMAT**는 메모리 접근의 평균 시간을 의미하며, 다음과 같은 수식을 통해 계산된다.

$AMAT = (PHit * T_{M}) + (PMiss * T_{D})$

  - **\( T_M \)**: 메모리 접근 비용 (단위: ns)
  - **\( T_D \)**: 디스크 접근 비용 (단위: μs)
  - **\( PHit \)**: 캐시에서 데이터를 찾을 확률 (히트 확률)
  - **\( PMiss \)**: 캐시에서 데이터를 찾지 못할 확률 (미스 확률, \( PMiss = 1 - PHit \))

### **예시 설명**
1. **시스템 설정**:
   - 페이지 크기는 4KB, 가상 주소는 256비트이며 상위 4비트는 **VPN(가상 페이지 번호)**, 하위 8비트는 **오프셋**으로 구성됩니다.
   - 한 프로세스가 총 6개의 가상 페이지에 접근하며, 가상 주소들은 첫 10개의 페이지의 첫 번째 바이트를 가리키고 있습니다.

2. **가정**:
   - 가상 페이지 중 3번 페이지를 제외한 모든 페이지는 이미 메모리에 존재한다고 가정합니다.
   - **\( T_M = 100 \) ns** (메모리 접근 비용)
   - **\( T_D = 10 \) μs** (디스크 접근 비용)

3. **메모리 접근 순서**:
   - 페이지 접근 순서는 **히트, 히트, 히트, 히트, 히트, 미스, 히트, 히트, 히트, 히트**로 진행됩니다.
   - 즉, 10번의 참조 중 9번은 메모리에서 찾았고, 1번은 메모리에 없어서 디스크 접근이 필요했습니다.
   - 따라서:
     - **히트율 (\( PHit \)) = 0.9**
     - **미스율 (\( PMiss \)) = 0.1**

4. **AMAT 계산**:
   \[
   AMAT = (0.9 \times 100ns) + (0.1 \times 10μs)
   \]
   - **\( 0.9 \times 100ns = 90ns \)**
   - **\( 0.1 \times 10μs = 1μs = 1000ns \)**
   - 따라서:
   \[
   AMAT = 90ns + 1000ns = 1090ns = 1.09μs
   \]

5. **히트율이 99.9%일 때**:
   - 히트율이 99.9%로 높아지면, AMAT는 훨씬 줄어듭니다:
   \[
   AMAT = (0.999 \times 100ns) + (0.001 \times 10μs) = 99.9ns + 10ns = 109.9ns \approx 0.11μs
   \]
   - 히트율이 높아질수록 평균 메모리 접근 시간이 크게 줄어드는 것을 볼 수 있습니다.
  
## 10.2 교체 정책

> 주기억장치의 모든 프레임이 사용되고 있고 페이지폴트 해결을 위해 새로운 페이지를 반입해야 할 때,
> 교체 정책은 현재 적재 되어 있는 페이지 중 어떤 페이지를 교체시킬지를 결정하는 것이다.

![image](https://github.com/user-attachments/assets/a78e5f76-2dcc-43d8-be08-81fa15485498)

### 1. Optimal 교체 정책
- 구현 불가
- 비현실적
- 미래를 예측하는 방식
- 가장 적은 페이지 폴트를 발생시킴

![image](https://github.com/user-attachments/assets/cee95fe1-1abd-4214-ba65-940fab50c36a)

### 2. Least Recently Used 교체 정책
> 가장 오랫동안 사용되지 않은 페이지를 교체

- 최근에 사용되지 않은 페이지가 가까운 미래에도 덜 사용될 가능성이 크다는 가정

![image](https://github.com/user-attachments/assets/36a3cd2e-fb03-40f8-9b75-9b09a34b4c99)

### 3. Least Frequently Used 교체 정책
> 가장 적게 사용된 페이지를 교체하는 정책

- 페이지가 적게 사용될수록 미래에도 덜 사용될 가능성이 있다고 가정

![image](https://github.com/user-attachments/assets/a137f21d-f555-4b08-960b-4e740e0e81ea)

### 4. FIFO 교체 정책
> 가장 먼저 메모리에 진입한 페이지를 교체하는 정책

![image](https://github.com/user-attachments/assets/d74e5b99-3f2a-4dff-9cec-75a4c1185e56)

### 5. LIFO 교체 정책
> 가장 나중에 메모리에 들어온 페이지를 교체하는 정책

![image](https://github.com/user-attachments/assets/e58628ff-83a7-4b16-a5d6-f55781829587)

### 6. Clock 교체 정책
> 현대 OS에서 사용하는 가장 성능이 휼륭한 정책이다.

- **페이지가 최근에 사용되었는지를 나타내는 사용비트(use bit)를 사용한다.**

- 페이지 Fault 발생 시 어떤 페이지가 메모리로 처음 들어올 때, 그 프레임의 use bit는 1로 설정된다.
- 해당 페이지가 사용될때마다 use bit를 1로 설정한다.
- Clock 포인터가 Circular queue를 돌때마다 사용하지 않은 페이지에 대해서는 use bit를 0으로 설정한다.
- 만약, 메모리가 가득 차서 페이지를 교체해야 할 때는 포인터가 가리키는 버퍼부터 시작해서 use bit가 0인 프레임을 찾아서 해당 프레임을 교체하는 방식

클록 알고리즘에서 변경 비트를 사용하는 방법
- 최근에 참조되지 않았으며 수정되지 않음 , (u = 0; m = 0)
- 최근에 참조되었으며 수정되지 않음 , (u = 1; m = 0)
- 최근에 참조되지 않았으며 수정됨 , (u = 0; m = 1)
- 최근에 참조되었으며 수정됨 , (u = 1; m = 1)

![image](https://github.com/user-attachments/assets/0b57f6fd-8c42-4e66-bb98-c91853babd9b)
