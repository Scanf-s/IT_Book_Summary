큰 주소 공간을 지원하기 위해, OS는 주소 공간 중에서
**현재 크게 필요하지 않은 일부를 보관해 둘 공간이 필요함** ==> SWAP

굳이 큰 주소 공간을 지원해야 하는 이유는?
=> 편리함, 용이성, CPU Utilization을 위함
- 만약 주소 공간이 충분히 크다면, 프로그램은 메모리 공간에 대한 걱정을 하지 않아도 됨. 그냥 메모리 할당만 요청하면 되기 때문

> Memory overlay
> - 프로그래머가 코드 또는 데이터의 일부를 수동으로 메모리에 탑재하는 것

## 9.1 Swap Space

> 스왑 공간 : 메모리의 공간이 부족하여 메모리에 탑재되어 있는 페이지를 빼내서 임시로 디스크에 저장해두는 장소
> 물리 메모리의 한계를 극복하고, 큰 주소 공간을 지원하기 위한 아주 중요한 기법이다.

![image](https://github.com/user-attachments/assets/b16542b6-0dda-43e6-826a-84388d3b8c33)

- 스왑 공간을 사용하여 물리 메모리의 부족한 공간을 보완할 수 있다.

스왑 공간은 **물리적 메모리**가 실제 용량보다 더 큰 것처럼 시스템을 운영할 수 있도록 해준다.
스왑 공간을 사용해서 여러 프로세스가 동시에 메모리를 사용할 수 있고, 필요할 때 **Swap in**을 하여 메모리로 불러올 수 있다.

- 스왑 공간의 크기는 매우 중요하다

> 스왑 공간에만 스왑을 할수있는건 아니다.
> **예를 들어, 처음 실행파일을 실행할때는, 스왑 공간에 해당 프로세스 페이지가 존재하지 않으므로, Disk에서 Swap in을 수행한다.**

### 메모리와 스왑의 상호작용
- **Swap out**
  프로세스가 물리적 메모리보다 큰 주소 공간을 필요로 할 때, 페이지를 스왑 공간으로 이동 (Swap out) 하여 물리 메모리의 여유를 확보한다.
- **Swap in**
  스왑 공간에 존재하는 페이지에 대해 다시 사용해야 하는 경우, (Swap in)을 통해 다시 메모리에 탑재한다.

### 멀티 프로그래밍에서의 스왑 공간
- 여러 프로그램이 동시에 실행될 때, 모든 프로그램의 페이지를 메모리에 올리는것은 불가능함
- 따라서 스왑 공간에 프로세스의 일부 페이지를 담고, 필요한 부분만 메모리에 올리는 방식을 사용한다.
- 이 방식을 통해 제한된 메모리를 효율적으로 활용할 수 있다.

## 9.2 Present bit

- 프로세스가 메모리를 참조할 때, 본인이 가지고 있는 가상 주소 공간을 사용해서 원하는 데이터를 접근함
- 하드웨어 (MMU)가 가상주소를 물리 주소로 변환하고, 메모리에서 데이터를 가져오는 방식
- 이 과정에서 VPN(가상 페이지 번호)를 추출하고, **TLB**를 확인한다.
- TLB Hit -> O(1)시간 안에 데이터를 가져올 수 있다.
- TLB Miss -> O(n)시간 정도로 페이지 테이블을 탐색하고, 변환 계산, TLB 갱신하여 데이터를 가져온다. -> 나중에 동일한 데이터 사용 시 TLB Hit

> Present bit의 역할은?
> - 페이지가 물리적 메모리에 현재 탑재되어 있는지 여부를 나타내는 비트
> - PTE(페이지 테이블 엔트리)에 이 Present bit가 1비트로 탑재되어 있음

Present bit가 1이면 : 현재 물리 메모리에 존재함
Present bit가 0이면 : 현재 물리 메모리에 존재하지 않음

## 9.3 Page fault

> Page fault란?
> Present bit가 0인 페이지에 접근하려고 할 때, 페이지 폴트가 발생한다.

페이지 폴트 발생 시 (TLB Miss), 하드웨어 관리 TLB와 소프트웨어 관리 TLB로 처리 방법이 나뉜다.

- 소프트웨어 관리 TLB가 (OS가처리) 처리한다면, **페이지 폴트 핸들러**를 호출해서 해결한다.
- 페이지 폴트 핸들러는 디스크에서 해당 페이지를 물리 메모리로 불러와준다.

### 페이지 폴트 처리 과정
1. 프로세스가 메모리 접근 시 필요한 페이지가 물리 메모리에 없을 때 Page fault 발생
   - PTE의 present bit가 0임을 확인함

2. 운영체제의 페이지 폴트 핸들러 호출
3. 디스크에서 페이지 위치 확인
   - PTE를 통해 디스크의 어느 위치에 저장되어 있는지 확인하고, Disk I/O 인터럽트가 발생함
4. 디스크로부터 페이지 가져오기
   - 디스크에 I/O 인터럽트를 발생시켜서 해당 페이지를 불러온다.
   - 일반적으로 오래 걸리는 작업이므로, 현재 실행되는 프로세스는 **Block state**가 된다.
5. Block State인 상태 동안, Ready state인 다른 프로세스를 실행해준다.
6. Disk I/O가 완료되어 페이지가 메모리로 로드되면, 페이지 테이블을 업데이트한다 (Present bit를 1로 설정한다)
7. TLB를 업데이트 해서 추후 빠르게 사용할 수 있도록 한다.
